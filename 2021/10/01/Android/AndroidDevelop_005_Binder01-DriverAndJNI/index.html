<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/desert.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/desert.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="OJnYjbr3wdT22qLrZSzyD9lAyBcXiXlEQ7-5wAnaWoQ">
  <meta name="baidu-site-verification" content="vr4n4JeXgB">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"852988.xyz","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="Binder 驱动分析以及 JNI 注册。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android - Binder机制(1)-驱动&#x2F;JNI">
<meta property="og:url" content="https://852988.xyz/2021/10/01/Android/AndroidDevelop_005_Binder01-DriverAndJNI/index.html">
<meta property="og:site_name" content="RangerZhou">
<meta property="og:description" content="Binder 驱动分析以及 JNI 注册。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//IPC_Triditional.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//IPC_Binder.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//UserSpaceAndKernelSpace.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//binder_arch.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//binder_driver.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022/Binder_%E6%B6%89%E5%8F%8A%E7%B1%BB.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022/Binder_%E7%B1%BB%E5%9B%BE.png">
<meta property="article:published_time" content="2021-10-01T04:36:10.000Z">
<meta property="article:modified_time" content="2026-01-08T16:41:43.217Z">
<meta property="article:author" content="Ranger Zhou">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//IPC_Triditional.png">


<link rel="canonical" href="https://852988.xyz/2021/10/01/Android/AndroidDevelop_005_Binder01-DriverAndJNI/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://852988.xyz/2021/10/01/Android/AndroidDevelop_005_Binder01-DriverAndJNI/","path":"2021/10/01/Android/AndroidDevelop_005_Binder01-DriverAndJNI/","title":"Android - Binder机制(1)-驱动/JNI"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android - Binder机制(1)-驱动/JNI | RangerZhou</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-138158952-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-138158952-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>

  <script src="/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?8ad0c721b994ab05ee97bd41ba54e048"></script>







  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
<script src="/js/comments.js" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">RangerZhou</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Read the fucking source code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-playlist"><a href="/playlist/" rel="section"><i class="fa fa-music fa-fw"></i>歌单</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li><li class="menu-item menu-item-official"><a href="/official" rel="section"><i class="fa fa-user fa-fw"></i>official</a></li><li class="menu-item menu-item-shop"><a href="http://rangerzhou.taobao.com/" rel="section" target="_blank"><i class="fa fa-user fa-fw"></i>shop</a></li><li class="menu-item menu-item-pansou"><a href="https://pansou.902519.xyz:8443/" rel="section" target="_blank"><i class="fa fa-video fa-fw"></i>pansou</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Binder-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1. Binder 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Binder-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="nav-text">2. Binder 有什么优势？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BC%A0%E7%BB%9F-IPC-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="nav-text">2.1 传统 IPC 传输数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Binder-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="nav-text">2.2 Binder 传输数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Linux-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">3. Linux 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-text">3.1 用户空间和内核空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-mmap-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">3.2 mmap 内存映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Linux-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="nav-text">3.3 Linux 设备驱动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Binder-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">4. Binder 架构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Binder-%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87"><span class="nav-text">4.1 Binder 驱动设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Client-%E7%AB%AF"><span class="nav-text">4.2 Client 端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Server-%E7%AB%AF"><span class="nav-text">4.3 Server 端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-ServiceManager"><span class="nav-text">4.4 ServiceManager</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Binder-%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87"><span class="nav-text">5. Binder 驱动设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-binder-init"><span class="nav-text">5.1 binder_init()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-binder-open"><span class="nav-text">5.2 binder_open()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-binder-mmap"><span class="nav-text">5.3 binder_mmap()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-binder-ioctl"><span class="nav-text">5.4 binder_ioctl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#binder-get-thread"><span class="nav-text">binder_get_thread()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E6%80%BB%E7%BB%93"><span class="nav-text">5.5 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-binder-JNI-%E6%B3%A8%E5%86%8C"><span class="nav-text">6. binder JNI 注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Binder-%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1%E5%8C%BA%E5%88%AB"><span class="nav-text">7. Binder 常见对象区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Binder-%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="nav-text">8. Binder 相关的类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Binder-%E7%B1%BB%E5%9B%BE"><span class="nav-text">9. Binder 类图</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ranger Zhou</p>
  <div class="site-description" itemprop="description">我是一个小流氓我从来也不浪，有一天我心血来潮耍了个流氓，我嘴里吹着小口哨我心里好得意，不知怎么哗啦啦啦啦我摔了一身泥</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/rangerzhou" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rangerzhou" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rangero_o@qq.com" title="E-Mail → mailto:rangero_o@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://rangerzhou.taobao.com/" title="Taobao → http:&#x2F;&#x2F;rangerzhou.taobao.com&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>Taobao</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → &#x2F;images&#x2F;wechat.jpg" rel="noopener me"><i class="fab fa-youtube fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://blog.csdn.net/ranger0220?viewmode=contents" title="CSDN → http:&#x2F;&#x2F;blog.csdn.net&#x2F;ranger0220?viewmode&#x3D;contents" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>CSDN</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://rangerzhou.taobao.com/" title="http:&#x2F;&#x2F;rangerzhou.taobao.com" rel="noopener" target="_blank">Taobao</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://852988.xyz/2021/10/01/Android/AndroidDevelop_005_Binder01-DriverAndJNI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ranger Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RangerZhou">
      <meta itemprop="description" content="我是一个小流氓我从来也不浪，有一天我心血来潮耍了个流氓，我嘴里吹着小口哨我心里好得意，不知怎么哗啦啦啦啦我摔了一身泥">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android - Binder机制(1)-驱动&#x2F;JNI | RangerZhou">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android - Binder机制(1)-驱动/JNI
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-01 12:36:10" itemprop="dateCreated datePublished" datetime="2021-10-01T12:36:10+08:00">2021-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-09 00:41:43" itemprop="dateModified" datetime="2026-01-09T00:41:43+08:00">2026-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/10/01/Android/AndroidDevelop_005_Binder01-DriverAndJNI/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/10/01/Android/AndroidDevelop_005_Binder01-DriverAndJNI/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>Binder 驱动分析以及 JNI 注册。</p>
</blockquote>
<span id="more"></span>

<h2 id="1-Binder-是什么？"><a href="#1-Binder-是什么？" class="headerlink" title="1. Binder 是什么？"></a>1. Binder 是什么？</h2><ul>
<li>机制：Binder 是一种进程间通信机制；</li>
<li>驱动：Binder 是一个虚拟物理设备驱动；</li>
<li>应用层：Binder 是一个能发起通信的 Binder.java 类；</li>
<li>Framework&#x2F;Native：Binder 连接了 Client、Server、ServiceManager 和 Binder 驱动程序，形成一套 C&#x2F;S 的通信架构；</li>
</ul>
<h2 id="2-Binder-有什么优势？"><a href="#2-Binder-有什么优势？" class="headerlink" title="2. Binder 有什么优势？"></a>2. Binder 有什么优势？</h2><p>Linux 进程间通信机制有：管道（匿名管道PIPE、命名管道FIFO）、信号、共享内存（无需拷贝，性能最好）、信号量（signal）、消息队列、socket（拷贝2次）；</p>
<table>
<thead>
<tr>
<th></th>
<th>Binder</th>
<th>共享内存</th>
<th>Socket</th>
</tr>
</thead>
<tbody><tr>
<td>性能</td>
<td>拷贝一次</td>
<td>无需拷贝</td>
<td>拷贝两次</td>
</tr>
<tr>
<td>特点</td>
<td>基于C&#x2F;S架构，易用性高，稳定性好</td>
<td>控制复杂，易用性差</td>
<td>基于C&#x2F;S架构，作为一款通用接口，其传输效率低，开销大</td>
</tr>
<tr>
<td>安全性</td>
<td>为每个APP分配UID，同时支持实名和匿名</td>
<td>依赖上层协议，访问接入点是开放的，不安全</td>
<td>依赖上层协议，访问接入点是开放的，不安全</td>
</tr>
</tbody></table>
<h3 id="2-1-传统-IPC-传输数据"><a href="#2-1-传统-IPC-传输数据" class="headerlink" title="2.1 传统 IPC 传输数据"></a>2.1 传统 IPC 传输数据</h3><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//IPC_Triditional.png">传统 IPC 机制</a></p>
<p><img src="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//IPC_Triditional.png" alt="TriditionalIPC" title="传统IPC机制"></p>
<p><strong>数据传输流程</strong></p>
<ul>
<li>发送数据</li>
<li><strong>第一次 copy</strong>：通过系统调用 copy_from_user() 将数据从用户空间 copy 到内核空间</li>
<li><strong>第二次 copy</strong>：通过系统调用 copy_to_user() 将数据从内核空间 copy 到用户空间</li>
<li>接收数据</li>
</ul>
<h3 id="2-2-Binder-传输数据"><a href="#2-2-Binder-传输数据" class="headerlink" title="2.2 Binder 传输数据"></a>2.2 Binder 传输数据</h3><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//IPC_Binder.png">IPC_Binder</a></p>
<p><img src="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//IPC_Binder.png" alt="IPC_Binder" title="Binder 进程间通信"></p>
<p><strong>数据传输流程</strong></p>
<ul>
<li>发送数据</li>
<li>一次 copy：通过系统调用 copy_from_user() 将数据从用户空间 copy 到内核空间，因为内核和接收方通过 mmap() 函数有一块共享内存区域，所以接收方可以直接接收数据；</li>
<li>接收数据</li>
</ul>
<h2 id="3-Linux-基础知识"><a href="#3-Linux-基础知识" class="headerlink" title="3. Linux 基础知识"></a>3. Linux 基础知识</h2><h3 id="3-1-用户空间和内核空间"><a href="#3-1-用户空间和内核空间" class="headerlink" title="3.1 用户空间和内核空间"></a>3.1 用户空间和内核空间</h3><p>内存被操作系统划分成两块：<strong>用户空间</strong>和<strong>内核空间</strong>，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方，内核空间是所有进程共享的。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响；</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//UserSpaceAndKernelSpace.png">用户空间和内核空间</a></p>
<p><img src="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//UserSpaceAndKernelSpace.png" alt="UserSpaceAndKernelSpace" title="用户空间和内核空间"></p>
<p>32位系统，即2^32，即总共可访问地址为4G。内核空间为1G，用户空间为3G，在用户态下运行时，内核的1GB是不可见的，但是当进程陷入到内核时是可以访问的；</p>
<p>64位系统，低位：0～47位才是有效的可变地址（寻址空间256T），高位：48～63位全补0或全补1。一般高位全补0对应的地址空间是用户空间。高位全补1对应的是内核空间；</p>
<h3 id="3-2-mmap-内存映射"><a href="#3-2-mmap-内存映射" class="headerlink" title="3.2 mmap 内存映射"></a>3.2 mmap 内存映射</h3><p>mmap 可以将一个文件或者其它对象映射进进程的用户空间，这种情况下，可以像使用自己进程的内存一样使用这段内存。Linux 系统的 mmap 函数原型是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 参数addr指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</span></span><br><span class="line"><span class="comment">// 参数length表示将文件中多大的部分映射到内存</span></span><br><span class="line"><span class="comment">// 参数prot指定映射区域的读写权限</span></span><br><span class="line"><span class="comment">// 参数flags指定映射时的特性，如是否允许其他进程映射这段内存</span></span><br><span class="line"><span class="comment">// 参数fd指定映射内存的文件描述符</span></span><br><span class="line"><span class="comment">// 参数offset指定映射位置的偏移量，一般为0</span></span><br></pre></td></tr></table></figure>

<p>非 mmap 或者内存共享的 Linux IPC 机制常用的通信方式如下，数据发送进程的用户空间数据通过 copy_from_user，复制到内核空间，由于内核空间是所有进程共享，所以内核通过调用 copy_to_user 将数据写入到数据接收进程，通过两次拷贝的方式，完成了 IPC 的通信。</p>
<p>通过 mmap 或者内存共享的 Linux IPC 机制，直接将同一段内存映射到数据发送进程和数据接收进程的用户空间，这样数据发送进程只需要将数据拷贝到共享的内存区域，数据接收进程就可以直接使用数据了。</p>
<h3 id="3-3-Linux-设备驱动"><a href="#3-3-Linux-设备驱动" class="headerlink" title="3.3 Linux 设备驱动"></a>3.3 Linux 设备驱动</h3><p>这里为什么要介绍 Linux 的设备驱动相关的知识呢？因为 Binder 的重要组成部分就是 Binder 驱动设备，为了更好的理解 Binder，我们需要知道什么是 Linux 的设备驱动。</p>
<p>Linux 的设备，主要包括字符设备（如键盘，鼠标，触摸屏等），块设备（硬盘，内存，U盘等）和网络接口（网卡，蓝牙等）等，都需要驱动程序才能和系统进行通信。这些驱动程序，都挂载在 dev 目录下，如硬盘的驱动挂载在 <code>dev/sda</code> 上，内存的驱动挂载在 <code>/dev/ram</code> 上。</p>
<p>块设备和字符设备的驱动程序一般都要实现 open、close、read 和 write 等系统调用函数，这些函数都属于系统 I&#x2F;O 函数，我们就可以直接通过 open 或者 read 等 I&#x2F;O 函数，读写设备的数据。而且 dev 目录下不仅仅是挂载真实的物理设备驱动，还可以挂载<strong>虚拟设备</strong>的驱动。虚拟设备的设计主要用来实现系统的功能，虽然虚拟设备没有具体的物理设备，但是我们依然需要在驱动程序中实现 I&#x2F;O 函数，只不过虚拟设备驱动的 I&#x2F;O 函数不是对物理设备的操作，而是功能逻辑操作。网桥就是 Linux 的一个虚拟设备，Binder 也是一个挂载在 <code>dev/binder</code> 下的虚拟设备。</p>
<h2 id="4-Binder-架构设计"><a href="#4-Binder-架构设计" class="headerlink" title="4. Binder 架构设计"></a>4. Binder 架构设计</h2><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//binder_arch.png">Binder 驱动</a></p>
<p><img src="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//binder_arch.png" alt="binder_driver" title="Binder 驱动"></p>
<p>Binder主要由这几部分组成：</p>
<ul>
<li>Binder 驱动设备</li>
<li>Client 端，数据发送端</li>
<li>Server 端，数据接收端</li>
<li>ServiceManager</li>
</ul>
<h3 id="4-1-Binder-驱动设备"><a href="#4-1-Binder-驱动设备" class="headerlink" title="4.1 Binder 驱动设备"></a>4.1 Binder 驱动设备</h3><p>Binder 驱动设备是真正分配内存空间用来存放通信数据的部分，在 Binder 的架构中，Clinet 端发送的数据拷贝到 Binder 驱动设备分配的内存空间中，Server 会通过 mmap 将 Binder 驱动设备中分配的内存映射到自己进程的用户空间中，映射完成后，Server 在用户空间就可以直接读取 Binder 驱动中存放数据的这段内存了。</p>
<h3 id="4-2-Client-端"><a href="#4-2-Client-端" class="headerlink" title="4.2 Client 端"></a>4.2 Client 端</h3><p>Client 端是数据发送方，它会通过 I&#x2F;O 函数，ioctl 陷入内核，通知 binder 驱动将 client 端的数据通过 copy_from_user 函数拷贝过来，并存放在 binder 驱动的内存中。</p>
<h3 id="4-3-Server-端"><a href="#4-3-Server-端" class="headerlink" title="4.3 Server 端"></a>4.3 Server 端</h3><p>Server 端是数据接收方，它接收数据的方式是映射 Binder 驱动中存放 Clinet 端数据的内存到自己的用户空间，这样就可以直接使用这段内存了。</p>
<h3 id="4-4-ServiceManager"><a href="#4-4-ServiceManager" class="headerlink" title="4.4 ServiceManager"></a>4.4 ServiceManager</h3><p>ServiceManager 是专门用来管理 Server 端的，Client 端想要和 Server 通信，必须知道 Server 的映射的内存地址，这样才能往这段内存中拷贝数据，但是我们不可能知道所有 Server 端的地址，所以这个时候，我们只需要知道 ServiceManager 的地址，在 ServiceManager 中寻找其他 Server 的地址就可以了，所以 ServiceManager 有点类似 DNS 服务器。</p>
<h2 id="5-Binder-驱动设备"><a href="#5-Binder-驱动设备" class="headerlink" title="5. Binder 驱动设备"></a>5. Binder 驱动设备</h2><p>Binder 是一个驱动，是一个 misc 设备，没有具体的硬件，本质就是一块内存，对于 Linux 来说，驱动就是一个文件（对于 Linux 一切皆文件），mmap() 函数即是把虚拟内存和物理内存（文件也是物理内存）联系起来，所以可以通过 mmap() 函数把虚拟内存和 binder 驱动联系起来。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//binder_driver.png">Binder 驱动设备</a></p>
<p><img src="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022//binder_driver.png" alt="binder_driver" title="Binder 驱动"></p>
<h3 id="5-1-binder-init"><a href="#5-1-binder-init" class="headerlink" title="5.1 binder_init()"></a>5.1 binder_init()</h3><p><a target="_blank" rel="noopener" href="http://androidxref.com/kernel_3.18/xref/drivers/staging/android/binder.c">kernel&#x2F;drivers&#x2F;staging&#x2F;android&#x2F;binder.c</a></p>
<p>binder 驱动和所有其他的设备驱动一样，Binder 驱动也是随着 Linux 的内核启动而一起启动的。在内核启动的过程中，只要位于 deriver 目录下的驱动程序在代码中按照规定的方式添加了初始化函数，这个驱动程序就会被内核自动加载，那么这个规定的方式是怎么样的呢？它的方式定义在 <a target="_blank" rel="noopener" href="http://androidxref.com/kernel_3.18/xref/include/linux/init.h">&#x2F;include&#x2F;linux&#x2F;init.h</a> 文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rootfs_initcall(fn)		__define_initcall(fn, rootfs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall(fn)		__define_initcall(fn, 6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall_sync(fn)	__define_initcall(fn, 6s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall(fn)		__define_initcall(fn, 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall_sync(fn)		__define_initcall(fn, 7s)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，里面有很多 xxx_initcall 的宏定义函数，如 core_initcall，device_initcall 等，这些宏定义都按照了优先级的顺序定义的，想要内核在启动的时候，能够启动驱动程序，只需要在驱动程序的代码里面加上 xxx_initcall 的宏定义方法，就能按照优先级被内核动态加载。</p>
<p>我们看看 Binder 驱动的源码，它位于 <code>/drivers/staging/</code> 目录下，我们知道 Linux 的 drivers 目录就是专门用来存放系统驱动程序的目录，它的源码里就可以看到 **device_initcall ** 这行代码，device_initcall 是最常用的一个 initcall 函数，于是内核在启动的过程中，就会自动的去加载 binder.c 驱动程序中的 binder_init 初始化函数。</p>
<p>入口函数是 device_initcall，调用到 binder_init()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">binder_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> *device_name, *device_names;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">device</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="comment">// 创建名为 binder 的单线程的工作队列</span></span><br><span class="line">	binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">&quot;binder&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!binder_deferred_workqueue)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">&quot;binder&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">		binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">&quot;proc&quot;</span>,</span><br><span class="line">						 binder_debugfs_dir_entry_root);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Copy the module_parameter string, because we don&#x27;t want to</span></span><br><span class="line"><span class="comment">	 * tokenize it in-place.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!device_names) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_device_names_failed;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 从 kernel/drivers/staging/android/Kconfig 文件中读取 ANDROID_BINDER_DEVICE 信息（&quot;binder&quot;）给到 device_name</span></span><br><span class="line">	<span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((device_name = strsep(&amp;device_names, <span class="string">&quot;,&quot;</span>))) &#123;</span><br><span class="line">		ret = init_binder_device(device_name); <span class="comment">// 初始化 binder</span></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device_initcall(binder_init); <span class="comment">// 设备驱动入口函数</span></span><br></pre></td></tr></table></figure>

<p><strong>init_binder_device</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_binder_device</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line"></span><br><span class="line">	binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL); <span class="comment">// 为 binder 设备分配内存(虚拟内存)</span></span><br><span class="line">	<span class="keyword">if</span> (!binder_device)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化设备</span></span><br><span class="line">	binder_device-&gt;miscdev.fops = &amp;binder_fops; <span class="comment">// 设备的文件操作结构，这是 file_operations 结构</span></span><br><span class="line">	binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR; <span class="comment">// 次设备号 动态分配</span></span><br><span class="line">	binder_device-&gt;miscdev.name = name; <span class="comment">// 设备名, &quot;binder&quot;</span></span><br><span class="line"></span><br><span class="line">	binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">	binder_device-&gt;context.name = name;</span><br><span class="line"></span><br><span class="line">	ret = misc_register(&amp;binder_device-&gt;miscdev); <span class="comment">// 注册 binder 为 misc 设备驱动</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(binder_device);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 hlist 节点添加到 binder_devices 为表头的设备链表</span></span><br><span class="line">	hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面讲 Linux 设备时，提到过 Linux 设备主要有字符设备，块设备等，杂项设备也属于 Linux 的一种设备类型，它是嵌入设系统用的比较多的一种设备。</p>
<p><strong>binder_fops</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>miscdev 定义了当前的驱动名为 binder，并指定了 open，mmap，unlocked_ioctl，compat_ioctl 等 I&#x2F;O 函数的实现函数。</p>
<p>binder_foops 是代码从 native 层调到 kernel 层的函数对应关系，比如 native 层调用 mmap() 函数，kernel 层对应的函数就是 binder_mmap()；</p>
<p>应用程序在调用 <code>ioctl</code> 进行设备控制时，最后会调用到设备注册 <code>struct file_operations</code> 结构体对象时的 <code>unlocked_ioctl</code> 或者 <code>compat_ioctl</code> 两个钩子上，具体是调用哪个钩子判断标准如下：</p>
<ul>
<li><code>compat_ioctl</code> : 32位的应用运行在64位的内核上，这个钩子被调用。</li>
<li><code>unlocked_ioctl</code>: 64位的应用运行在64位的内核或者32位的应用运行在32位的内核上，则调用这个钩子。<br>Binder 做为 Android 中进程间高效通信的核心组件，其底层是以 misc 设备驱动的形式实现的，但它本身并没有实现 <code>read</code>,<code>write</code> 操作，所有的控制都是通过 <code>ioctl</code> 操作来实现。在 Binder 驱动的 <code>struct file_operations</code> 定义中可见，它的 <code>compat_ioctl</code> 和 <code>unlocked_ioctl</code> 两个钩子的的实现都是对应到 <code>binder_ioctl</code> 上的。</li>
</ul>
<p><strong>binder_device</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-binder-open"><a href="#5-2-binder-open" class="headerlink" title="5.2 binder_open()"></a>5.2 binder_open()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_dev</span>;</span></span><br><span class="line"></span><br><span class="line">	binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">&quot;binder_open: %d:%d\n&quot;</span>,</span><br><span class="line">		     current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line"></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); <span class="comment">// 为 binder_proc 结构体在 kernel 分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current); <span class="comment">// 将当前进程(调用 binder_open 的进程)的 task 保存到 binder 进程的 tsk</span></span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo); <span class="comment">// 初始化 todo 列表（目标任务）</span></span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait); <span class="comment">// 初始化 wait 队列（当前进程处理的任务）</span></span><br><span class="line">	proc-&gt;default_priority = task_nice(current); <span class="comment">// 将当前进程的 nice 值转换为进程优先级</span></span><br><span class="line">	binder_dev = container_of(filp-&gt;private_data, <span class="keyword">struct</span> binder_device,</span><br><span class="line">				  miscdev);</span><br><span class="line">	proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line"></span><br><span class="line">	binder_lock(__func__); <span class="comment">// 同步锁，因为 binder 支持多线程访问</span></span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC); <span class="comment">// binder_proc 对象创建数加1</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); <span class="comment">// 将 proc_node 节点添加到 binder_procs 的队列头部</span></span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid; <span class="comment">// 进程 pid</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);  <span class="comment">// 初始化已分发的死亡通知列表</span></span><br><span class="line">	filp-&gt;private_data = proc; <span class="comment">// 将 binder_proc 与 filp 关联起来，这样下次通过 filp 就能找到这个 proc 了</span></span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__); <span class="comment">// 释放同步锁</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>binder_proc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span> <span class="comment">// 进程节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span> <span class="comment">// binder_thread红黑树的根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span> <span class="comment">// binder_node红黑树的根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span> <span class="comment">// binder_ref红黑树的根节点(以 handle为 key)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span> <span class="comment">// binder_ref红黑树的根节点（以 ptr为 key）</span></span><br><span class="line">    <span class="type">int</span> pid; <span class="comment">// 相应进程 id</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span> <span class="comment">// 指向进程虚拟地址空间的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vma_vm_mm</span>;</span> <span class="comment">// 相应进程的内存结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span> <span class="comment">// 相应进程的 task结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 相应进程的文件结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line">    <span class="type">int</span> deferred_work;</span><br><span class="line">    <span class="type">void</span> *buffer; <span class="comment">// 内核空间的起始地址</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> user_buffer_offset; <span class="comment">// 内核空间与用户空间的地址偏移量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffers</span>;</span> <span class="comment">// 所有的 buffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">free_buffers</span>;</span> <span class="comment">// 空闲的 buffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">allocated_buffers</span>;</span> <span class="comment">// 已分配的 buffer</span></span><br><span class="line">    <span class="type">size_t</span> free_async_space; <span class="comment">// 异步的可用空闲空间大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span> <span class="comment">// 指向物理内存页指针的指针</span></span><br><span class="line">    <span class="type">size_t</span> buffer_size; <span class="comment">// 映射的内核空间大小</span></span><br><span class="line">    <span class="type">uint32_t</span> buffer_free; <span class="comment">// 可用内存总大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span> <span class="comment">// 进程将要做的事</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait; <span class="comment">// 等待队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span> <span class="comment">// binder统计信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">delivered_death</span>;</span> <span class="comment">// 已分发的死亡通知</span></span><br><span class="line">    <span class="type">int</span> max_threads; <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="type">int</span> requested_threads; <span class="comment">// 请求的线程数</span></span><br><span class="line">    <span class="type">int</span> requested_threads_started; <span class="comment">// 已启动的请求线程数</span></span><br><span class="line">    <span class="type">int</span> ready_threads; <span class="comment">// 准备就绪的线程个数</span></span><br><span class="line">    <span class="type">long</span> default_priority; <span class="comment">// 默认优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_entry</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-binder-mmap"><a href="#5-3-binder-mmap" class="headerlink" title="5.3 binder_mmap()"></a>5.3 binder_mmap()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span> <span class="comment">// 内核的虚拟内存，vma 是进程的虚拟内存</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *failure_string;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;tsk != current)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保证映射内存大小不超过 4M（是驱动定的，实际上应用层定的是 1M-8K）</span></span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line">	...</span><br><span class="line">	mutex_lock(&amp;binder_mmap_lock); <span class="comment">// 同步锁，保证一次只有一个进程分配内存，保证多进程间的并发访问</span></span><br><span class="line">	<span class="comment">// 是否已经做过映射，执行过则进入 if，goto 跳转，释放同步锁后结束 binder_mmap 方法</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;buffer) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		failure_string = <span class="string">&quot;already mapped&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_already_mapped;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 采用 VM_IOREMAP方式，分配一个连续的内核虚拟内存，与进程虚拟内存大小一致</span></span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">	<span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123; <span class="comment">// 内存分配不成功直接报错</span></span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">&quot;get_vm_area&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;buffer = area-&gt;addr; <span class="comment">// 将 proc 中的 buffer 指针指向这块内核的虚拟内存</span></span><br><span class="line">	<span class="comment">// 计算出用户空间和内核空间的地址偏移量。地址偏移量 = 用户虚拟内存地址 - 内核虚拟内存地址</span></span><br><span class="line">	proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="type">uintptr_t</span>)proc-&gt;buffer;</span><br><span class="line">	mutex_unlock(&amp;binder_mmap_lock); <span class="comment">// 释放锁</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 分配物理页的指针数组，数组大小为 vma 的等效 page 个数</span></span><br><span class="line">	proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">&quot;alloc page array&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">	vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配物理页面，同时映射到内核空间和进程空间，先分配 1 个物理页</span></span><br><span class="line">	<span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">&quot;alloc small buf&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_small_buf_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	buffer = proc-&gt;buffer;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;buffers);</span><br><span class="line">	list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers); <span class="comment">// 将 buffer 连入 buffers 链表中</span></span><br><span class="line">	<span class="comment">// 上面 binder_update_page_range 已经分配内存了，此处表示此内存可用</span></span><br><span class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">	binder_insert_free_buffer(proc, buffer); <span class="comment">// 将 buffer 插入 proc-&gt;free_buffers 链表中</span></span><br><span class="line">	proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>; <span class="comment">// 异步的可用空闲空间大小</span></span><br><span class="line">	barrier();</span><br><span class="line">	proc-&gt;files = get_files_struct(current);</span><br><span class="line">	proc-&gt;vma = vma;</span><br><span class="line">	proc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>struct vm_area_struct *vma： 表示用户空间的一段虚拟内存区域；</li>
<li>struct vm_struct *area：表示内核空间的一段连续的虚拟内存区域；</li>
</ul>
<p>新版本内核代码 4.19 已经不再此处映射了：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/159189816">https://zhuanlan.zhihu.com/p/159189816</a></p>
<p><strong>binder_update_page_range</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_update_page_range</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc, <span class="type">int</span> allocate,</span></span><br><span class="line"><span class="params">				    <span class="type">void</span> *start, <span class="type">void</span> *end,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *page_addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> user_page_addr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// allocate 为 1，代表分配内存过程；如果为 0 则代表释放内存过程</span></span><br><span class="line">	<span class="keyword">if</span> (allocate == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_range;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line"></span><br><span class="line">		BUG_ON(*page);</span><br><span class="line">        <span class="comment">// 分配一个 page(4K) 的物理内存</span></span><br><span class="line">		*page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);</span><br><span class="line">		<span class="keyword">if</span> (*page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;%d: binder_alloc_buf failed for page at %p\n&quot;</span>,</span><br><span class="line">				proc-&gt;pid, page_addr);</span><br><span class="line">			<span class="keyword">goto</span> err_alloc_page_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 把内核空间的虚拟内存映射到上面分配的 4K 物理内存</span></span><br><span class="line">		ret = map_kernel_range_noflush((<span class="type">unsigned</span> <span class="type">long</span>)page_addr,</span><br><span class="line">					PAGE_SIZE, PAGE_KERNEL, page);</span><br><span class="line">		...</span><br><span class="line">		user_page_addr =</span><br><span class="line">			(<span class="type">uintptr_t</span>)page_addr + proc-&gt;user_buffer_offset;</span><br><span class="line">		<span class="comment">// 把用户空间的虚拟内存映射到上面分配的 4K 物理内存</span></span><br><span class="line">		ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-binder-ioctl"><a href="#5-4-binder-ioctl" class="headerlink" title="5.4 binder_ioctl"></a>5.4 binder_ioctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 进入休眠状态，直到中断唤醒</span></span><br><span class="line">	ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>); </span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据当前进程的 pid，从 binder_proc 中查找 binder_thread, </span></span><br><span class="line">	<span class="comment">// 如果当前线程已经加入到 proc 的线程队列则直接返回，如果不存在则创建 binder_thread，并将当前线程添加到当前的 proc</span></span><br><span class="line">	thread = binder_get_thread(proc);</span><br><span class="line">	<span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行 binder 的读写操作</span></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="comment">// BINDER_WRITE_READ 这个用的比较多，比较重要</span></span><br><span class="line">	<span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">		ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS: &#123;</span><br><span class="line">        <span class="type">int</span> max_threads;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;max_threads, ubuf,</span><br><span class="line">                   <span class="keyword">sizeof</span>(max_threads))) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        proc-&gt;max_threads = max_threads;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> <span class="title">fbo</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;fbo, ubuf, <span class="keyword">sizeof</span>(fbo))) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = binder_ioctl_set_ctx_mgr(filp, &amp;fbo);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        ret = binder_ioctl_set_ctx_mgr(filp, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_THREAD_EXIT:</span><br><span class="line">		binder_debug(BINDER_DEBUG_THREADS, <span class="string">&quot;%d:%d exit\n&quot;</span>,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		binder_free_thread(proc, thread);</span><br><span class="line">		thread = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_VERSION: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_version</span> __<span class="title">user</span> *<span class="title">ver</span> =</span> ubuf;</span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_version)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">                 &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (thread)</span><br><span class="line">        thread-&gt;looper_need_return = <span class="literal">false</span>; <span class="comment">// 注意此处又把 looper_need_return 设置为了 true</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>__user：<code>__user</code> 是一个宏，它告诉编译器不应该解除这个指针的引用（因为在当前地址空间中它是没有意义的），<code>(void __user *)arg</code> 表示 <code>arg</code> 是一个用户空间地址，不能直接进行拷贝，必须使用 <code>copy_from_user/copy_to_user</code> 等函数拷贝；</li>
<li>wait_event_interruptible：也是一个宏，它是用来挂起进程直到满足判断条件的，<code>binder_stop_on_user_error</code> 是一个全局变量，它的初始值为 0，<code>binder_user_error_wait</code> 是一个等待队列，在正常情况下，<code>binder_stop_on_user_error &lt; 2</code> 这个条件是成立的，所以不会进入挂起状态，而当<code>binder</code> 因为错误而停止后，调用 <code>binder_ioctl</code>，则会挂起进程，直到其他进程通过 <code>wake_up_interruptible</code> 来唤醒 <code>binder_user_error_wait</code> 队列，并且满足 <code>binder_stop_on_user_error &lt; 2</code> 这个条件，<code>binder_ioctl</code> 才会继续往后运行；</li>
</ul>
<p><code>接着来看一下 binder_get_thread()</code>；</p>
<h4 id="binder-get-thread"><a href="#binder-get-thread" class="headerlink" title="binder_get_thread()"></a>binder_get_thread()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_thread *<span class="title function_">binder_get_thread</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">new_thread</span>;</span></span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    thread = binder_get_thread_ilocked(proc, <span class="literal">NULL</span>);</span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line">    <span class="keyword">if</span> (!thread) &#123;</span><br><span class="line">        new_thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (new_thread == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        thread = binder_get_thread_ilocked(proc, new_thread);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (thread != new_thread)</span><br><span class="line">            kfree(new_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用 <code>binder_get_thread_ilocked()</code> 获取线程，如果获取不到，则通过 <code>kzalloc()</code> 分配内存并把所分配内存对象的引用传递给 new_thread，然后再次通过<code>binder_get_thread_ilocked(proc, new_thread)</code>来获取 thread，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_thread *<span class="title function_">binder_get_thread_ilocked</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *new_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;proc-&gt;threads.rb_node;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        thread = rb_entry(parent, <span class="keyword">struct</span> binder_thread, rb_node);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!new_thread)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    thread = new_thread;</span><br><span class="line">    binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">    thread-&gt;proc = proc;</span><br><span class="line">    thread-&gt;pid = current-&gt;pid;</span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    thread-&gt;task = current;</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;thread-&gt;tmp_ref, <span class="number">0</span>);</span><br><span class="line">    init_waitqueue_head(&amp;thread-&gt;wait);</span><br><span class="line">    INIT_LIST_HEAD(&amp;thread-&gt;todo);</span><br><span class="line">    rb_link_node(&amp;thread-&gt;rb_node, parent, p);</span><br><span class="line">    rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line">    thread-&gt;looper_need_return = <span class="literal">true</span>; <span class="comment">// 此处配置了 looper_need_return 为 true</span></span><br><span class="line">    thread-&gt;return_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">    thread-&gt;return_error.cmd = BR_OK;</span><br><span class="line">    thread-&gt;reply_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">    thread-&gt;reply_error.cmd = BR_OK;</span><br><span class="line">    INIT_LIST_HEAD(&amp;new_thread-&gt;waiting_thread_node); <span class="comment">// 初始化链表（next/prev 指针都指向自己）</span></span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数先是根据 proc 获取对应红黑树上的节点，如果获取不到则返回 thread（为 NULL），分配内存后再次进入此函数，执行 <code>while()</code> 循环后面的代码，把 new_thread 传递给 thread，并初始化了一些参数，<font color=red><strong>注意此处 <code>looper_need_return = true</code></strong></font>，这个参数在 <code>binder_thread_read()</code>判断是否休眠时会用到，不过<font color=red><strong>在 <code>binder_ioctl()</code> 的结尾处又把 looper_need_return 配置为了 false</strong></font>，所以应用程序在刚启动创建 binder 线程池时，先启动了一个 binder 主线程，在主线程第一次调用 binder_ioctl 时是不会阻塞在 binder_thread_read() 的，另外也初始化了 todo 和 waiting_thread_node 这两个链表；</p>
<p>继续回到 <code>binder_ioctl()</code> 函数中，BINDER_WRITE_READ 这个 case 比较重要，因为应用程序是通过 <code>ioctl(mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code> 这样调用，然后就调用到了 binder_ioctl 的 BINDER_WRITE_READ 这个 case；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_ioctl_write_read</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 把用户空间数据 ubuf 拷贝到 bwr(此次拷贝的是数据头，而非有效数据)</span></span><br><span class="line">    <span class="comment">// 这里的 copy_from_user() 方法并没有拷贝要传输的数据，而仅是拷贝了持有传输数据内存地址的 bwr https://www.bilibili.com/read/cv7592830/</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 当写缓存中有数据，则执行 binder 写操作</span></span><br><span class="line">	<span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ret = binder_thread_write(proc, thread,</span><br><span class="line">					  bwr.write_buffer,</span><br><span class="line">					  bwr.write_size,</span><br><span class="line">					  &amp;bwr.write_consumed);</span><br><span class="line">		trace_binder_write_done(ret);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当读缓存中有数据，则执行 binder 读操作</span></span><br><span class="line">	<span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">					 bwr.read_size,</span><br><span class="line">					 &amp;bwr.read_consumed,</span><br><span class="line">					 filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">		trace_binder_read_done(ret);</span><br><span class="line">		<span class="comment">// 进程 todo 队列不为空,则唤醒该队列中的线程</span></span><br><span class="line">		<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">			wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 把内核空间数据 bwr 拷贝到 ubuf</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的 copy_from_user 拷贝的并不是真正的有效数据，而是数据头，真正的有效数据是在其他地方拷贝的；</p>
<p>binder_ioctl_write_read 流程</p>
<ul>
<li>首先把用户空间的数据拷贝到内核空间 bwr</li>
<li>其次当 bwr 写缓存中有数据，则执行 binder 写操作。如果写失败，则再将 bwr 数据写回用户空间，并退出</li>
<li>再次当 bwr 读缓存中有数据，则执行 binder 读缓存；当读失败，再将 bwr 数据写回用户空间，并退出</li>
<li>最后把内核数据拷贝到用户空间</li>
</ul>
<h3 id="5-5-总结"><a href="#5-5-总结" class="headerlink" title="5.5 总结"></a>5.5 总结</h3><p><strong>binder_init()</strong> 主要工作：</p>
<ul>
<li>kzalloc：分配内存；</li>
<li>初始化设备；</li>
<li>hlist_add_head：将 binder_device 的 hlist 节点添加到 binder_devices 为表头的设备链表；</li>
</ul>
<p><strong>binder_open()</strong> 主要工作：</p>
<ul>
<li>为调用 binder_open 的进程创建一个 binder_proc 结构体对象 proc；</li>
<li>将当前进程信息（调用 binder_open 的进程）保存到 proc；</li>
<li>把 proc 的 proc_node 添加到 binder_procs 链表中；</li>
<li>filp-&gt;private_data &#x3D; proc：把 proc 和 filp 关联，以便下次通过 filp 找到 proc；</li>
</ul>
<p><strong>binder_mmap()</strong> 主要工作：</p>
<ul>
<li>根据用户空间的虚拟内存大小，分配一块内核的虚拟内存；</li>
<li>分配一块物理内存（4K，之所以这么小是因为现在还没有通信，等到真正通信的时候再增加，以免浪费内存）；</li>
<li>把分配的物理内存分别映射到内核空间虚拟内存和用户空间虚拟内存；</li>
</ul>
<p><strong>binder_ioctl()</strong> 主要工作：</p>
<ul>
<li>binder_ioctl() 函数负责在两个进程间收发 IPC 数据和 IPC reply 数据；</li>
</ul>
<h2 id="6-binder-JNI-注册"><a href="#6-binder-JNI-注册" class="headerlink" title="6. binder JNI 注册"></a>6. binder JNI 注册</h2><p><a href="">frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp</a></p>
<p><strong>app_main.main()</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="">frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</a></p>
<p><strong>AndroidRuntime.start()</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* className, <span class="type">const</span> Vector&lt;String8&gt;&amp; options, <span class="type">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startReg</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>AndroidRuntime.startReg()</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> <span class="function"><span class="type">int</span> <span class="title">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">register_jni_procs</span>(gRegJNI, <span class="built_in">NELEM</span>(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">PopLocalFrame</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><strong>AndroidRuntime.register_jni_procs()</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="type">const</span> RegJNIRec array[], <span class="type">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i].<span class="built_in">mProc</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		   ...</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">REG_JNI</span>(register_android_os_SystemProperties),</span><br><span class="line">        <span class="built_in">REG_JNI</span>(register_android_os_Binder),</span><br></pre></td></tr></table></figure>

<p><a href="">frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp</a></p>
<p><strong>android_util_Binder.register_android_os_Binder()</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int_register_android_os_Binder</span>(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int_register_android_os_BinderInternal</span>(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int_register_android_os_BinderProxy</span>(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>android_util_Binder.int_register_android_os_Binder()</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gBinderMethods[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;getCallingPid&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getCallingPid &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getCallingUid&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getCallingUid &#125;,</span><br><span class="line">    ...</span><br><span class="line">    &#123; <span class="string">&quot;getExtension&quot;</span>, <span class="string">&quot;()Landroid/os/IBinder;&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getExtension &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;setExtension&quot;</span>, <span class="string">&quot;(Landroid/os/IBinder;)V&quot;</span>, (<span class="type">void</span>*)android_os_Binder_setExtension &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> kBinderPathName = <span class="string">&quot;android/os/Binder&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查找文件 kBinderPathName = &quot;android/os/Binder&quot;，返回对应 Class 对象</span></span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderPathName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 gBinderOffsets 结构体，保存 Java 层 Binder 类的信息，为 native 层访问 Java 层提供通道</span></span><br><span class="line">    gBinderOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);</span><br><span class="line">    gBinderOffsets.mExecTransact = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;execTransact&quot;</span>, <span class="string">&quot;(IJJI)Z&quot;</span>);</span><br><span class="line">    gBinderOffsets.mGetInterfaceDescriptor = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;getInterfaceDescriptor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    gBinderOffsets.mObject = <span class="built_in">GetFieldIDOrDie</span>(env, clazz, <span class="string">&quot;mObject&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 RegisterMethodsOrDie，将为 gBinderMethods 数组完成映射关系，从而为 Java 层访问 JNI 层提供通道</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, <span class="built_in">NELEM</span>(gBinderMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int_register_android_os_Binder 的作用就是让 Java 层和 native 层能够互相调用；</p>
<h2 id="7-Binder-常见对象区别"><a href="#7-Binder-常见对象区别" class="headerlink" title="7. Binder 常见对象区别"></a>7. Binder 常见对象区别</h2><p>初见 BinderProxy、BpBinder、binder_ref、binder_node、BBinder、Binder 简直一脸懵逼，头都 TMD 绕晕了，有什么区别呢？</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>BpBinder —— Binder 代理对象</td>
<td>在用户空间创建，且执行在 Client 进程中，会被 Client 进程中的其他对象引用，另外会<strong>引用 Binder 驱动程序中的 Binder 引用对象</strong></td>
</tr>
<tr>
<td>binder_ref —— Binder 引用对象</td>
<td>在 Binder 驱动程序中创建，<strong>被 Binder 代理对象引用</strong></td>
</tr>
<tr>
<td>binder_node —— Binder 实体对象</td>
<td>在 Binder 驱动程序中创建，<strong>被 Binder 引用对象所引用</strong></td>
</tr>
<tr>
<td>BBinder —— Binder 本地对象</td>
<td>在用户空间创建，且执行在 Server 进程中，<strong>会被 Server 进程中其他对象引用，还会被 Binder 实体对象引用</strong></td>
</tr>
</tbody></table>
<p>Binder 实体（binder_node）：是各个 Server 以及 ServiceManager 在内核中的存在形式。实际上是内核中 binder_node 结构体的对象 ，它的作用是在内核中保存 Server 和 ServiceManager 的信息(例如，Binder 实体中保存了 Server 对象在用户空间的地址)。简言之，Binder 实体是 Server 在 Binder 驱动中的存在形式，内核通过 Binder 实体可以找到用户空间的 Server 对象。  </p>
<p>Binder 引用&#x2F;代理（binder_ref）：所谓 Binder 引用，实际上是内核中 binder_ref 结构体的对象，它的作用是在表示<code>Binder 实体</code>的引用。换句话说，每一个 Binder 引用都是某一个 Binder 实体的引用，通过 Binder 引用可以在内核中找到它对应的Binder实体。</p>
<p>Binder 实体和 Binder 引用都是内核（Binder 驱动）中的数据结构。每一个 Server 在内核中就表现为一个 Binder 实体，在每一个 Client 中则表现为一个 Binder 引用。这样，每个 Binder 引用都对应一个 Binder 实体，而每个 Binder 实体则可以多个 Binder 引用。</p>
<p>引用关系：BpBinder ——&gt; binder_ref ——&gt; binder_node ——&gt; BBinder</p>
<h2 id="8-Binder-相关的类"><a href="#8-Binder-相关的类" class="headerlink" title="8. Binder 相关的类"></a>8. Binder 相关的类</h2><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022/Binder_%E6%B6%89%E5%8F%8A%E7%B1%BB.png">Binder_涉及类</a></p>
<p><img src="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022/Binder_%E6%B6%89%E5%8F%8A%E7%B1%BB.png" alt="Binder_涉及类" title="Binder 涉及类"></p>
<h2 id="9-Binder-类图"><a href="#9-Binder-类图" class="headerlink" title="9. Binder 类图"></a>9. Binder 类图</h2><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022/Binder_%E7%B1%BB%E5%9B%BE.png">Binder_类图</a></p>
<p><img src="https://raw.githubusercontent.com/rangerzhou/ImageHosting/master/blog_resource/2022/Binder_%E7%B1%BB%E5%9B%BE.png" alt="Binder_类图" title="Binder 类图"></p>
<ul>
<li>Binder(Java) 对象持有的 mObject 是 JavaBBinderHolder 的引用；</li>
<li>JavaBBinderHolder 对象持有一个 mBinder 弱引用，promote 为强引用后指向 JavaBBinder 对象；</li>
<li>JavaBBinder 对象持有的 mObject 是 Binder 对象的 GlobalRef（将 Binder 对象加入到 art::globals_ 列表中，这样 Binder 对象在每次 GC 时都会被标记为 GC Root，也便无法被回收，只有当 JavaBBinder 对象销毁时，Binder 对象才能从 art::globals_ 中清除，才能被销毁）；</li>
</ul>
<p>补充待整理：</p>
<p>BinderProxy 就是 BpBinder，”BpBinder” 中的 “p” 即 Proxy，只不过 BpBinder 是 Native 层的，BinderProxy 是 Java 层的。BinderProxy 和 BpBinder 分别继承自 Java 层和 Native 层的 IBinder 接口，即 IBinder.h 和 IBinder.java，它们可以看作同一个接口，都定义了 transact 等方法。</p>
<p>Ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/tyuiof/article/details/108290327">深入理解Android进程间通信机制</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Ranger Zhou 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Ranger Zhou 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/13/Android/AndroidDevelop_000_Debug_Tools/" rel="prev" title="Android —— 调试工具和命令汇总">
                  <i class="fa fa-angle-left"></i> Android —— 调试工具和命令汇总
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/12/Android/AndroidDevelop_006_Binder02-ServiceManager-BootAndGet/" rel="next" title="Android - Binder机制(2)-ServiceManager启动和获取">
                  Android - Binder机制(2)-ServiceManager启动和获取 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-disqus">disqus</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments gitalk-container"></div>
            </div>
            <div class="tab-pane livere" id="comment-livere">
              <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC8yOTcyNS82Mjky"></div>
            </div>
            <div class="tab-pane disqus" id="comment-disqus">
              
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ranger Zhou</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
    <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
    
    <div id="aplayer-fixed" class="aplayer"></div>

    <script>
      const ap = new APlayer({
        container: document.getElementById('aplayer-fixed'),
        fixed: true,          // 吸底模式
        mini: true,           // 迷你模式
        order: 'random',      // 随机播放
        autoplay: true,       // 自动播放
        audio: [
        {
          name: '成都',
          artist: '赵雷',
          url: '/music/成都.mp3',   // 这里的路径相对于 source 目录
          cover: '/music-cover/成都.jpg'   // 封面图路径
        },
        {
          name: 'AmysLullabyII',
          artist: 'Mars Lasar',
          url: '/music/AmysLullabyII.mp3',
          cover: '/music-cover/AmysLullabyII.jpg'
        },
        {
          name: 'Five Hundred Miles',
          artist: 'Justin Timberlake; ',
          url: '/music/FiveHundredMiles.mp3',
          cover: '/music-cover/FiveHundredMiles.jpg'
        },
        {
          name: 'On a Slow Boat To China',
          artist: 'Luke Thompson',
          url: '/music/OnaSlowBoatToChina.mp3',
          cover: '/music-cover/OnaSlowBoatToChina.jpg'
        },
        {
          name: '阿拉斯加海湾',
          artist: '蓝心羽',
          url: '/music/阿拉斯加海湾.mp3',
          cover: '/music-cover/阿拉斯加海湾.jpg'
        },
        {
          name: '安河桥',
          artist: '宋冬野',
          url: '/music/anheqiao.mp3',
          cover: '/music-cover/安河桥.jpg'
        },
        {
          name: '好久不见',
          artist: '陈奕迅',
          url: '/music/好久不见.mp3',
          cover: '/music-cover/好久不见.jpg'
        },
        {
          name: '麻雀',
          artist: '李荣浩',
          url: '/music/麻雀.mp3',
          cover: '/music-cover/麻雀.jpg'
        },
        {
          name: '平凡之路',
          artist: '朴树',
          url: '/music/平凡之路.mp3',
          cover: '/music-cover/平凡之路.jpg'
        },
        {
          name: '听闻远方有你',
          artist: '刘艺雯',
          url: '/music/听闻远方有你.mp3',
          cover: '/music-cover/听闻远方有你.jpg'
        },
        {
          name: '无赖',
          artist: '郑中基',
          url: '/music/无赖.mp3',
          cover: '/music-cover/无赖.jpg'
        },
        {
          name: '呓语',
          artist: '蒋卓林',
          url: '/music/呓语.mp3',
          cover: '/music-cover/呓语.jpg'
        },
        {
          name: '这些民谣一次听个够',
          artist: '翁大涵',
          url: '/music/这些民谣一次听个够.mp3',
          cover: '/music-cover/这些民谣一次听个够.jpg'
        }
        ]
      });
    </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"rangerzhou","repo":"rangerzhou.github.io","client_id":"b7bb504993135f5a2eab","client_secret":"6f83aec5c45d75e248e2914be90c4601e2e1dc44","admin_user":"rangerzhou","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","body":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"1b8360869f005ad66fd55f1d08e43474"}</script>
<script src="/js/third-party/comments/gitalk.js" defer></script>
<script src="/js/third-party/comments/livere.js" defer></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"rangerzhou","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haru01.model.json"},"display":{"position":"left","width":100,"height":266,"vOffset":64},"mobile":{"show":false},"log":false});</script></body>
</html>
